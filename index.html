export interface Env {
  WEBHOOK_SECRET_S4631?: string; // hex
}

const ALLOWED_DRIFT_MS = 5 * 60 * 1000; // 5分钟时间窗

export default {
  async fetch(req: Request, env: Env): Promise<Response> {
    if (req.method === 'OPTIONS') {
      return cors(new Response(null, { status: 204 }));
    }
    if (req.method !== 'POST') {
      return cors(json({ ok: false, message: 'Method Not Allowed' }, 405));
    }

    // 1) 原始字节 + 文本
    const raw = await req.arrayBuffer();
    const bodyText = new TextDecoder().decode(raw);

    // 2) 先校验签名（失败直接 401）
    const sigHeader = req.headers.get('X-Signature') || '';
    const tsHeader = req.headers.get('X-Timestamp') || '';
    const corId = req.headers.get('X-Epic-Correlation-ID') || undefined;

    if (!tsHeader || !isFreshTimestamp(tsHeader, ALLOWED_DRIFT_MS)) {
      return cors(json({ ok: false, message: 'Invalid or missing X-Timestamp' }, 401, corId));
    }

    const okSig = await verifyEpicSignature(sigHeader, new Uint8Array(raw), env);
    if (!okSig) {
      return cors(json({ ok: false, message: 'Invalid or missing X-Signature' }, 401, corId));
    }

    // 3) 业务解析
    let body: any = null;
    try { body = JSON.parse(bodyText); }
    catch { return cors(json({ ok: false, message: 'Invalid JSON' }, 400, corId)); }

    const { eventType } = body || {};
    const hasEventId = typeof body?.eventId === 'string' && body.eventId.length > 0;

    // 4) 针对验证测试的最小实现
    switch (eventType) {
      case 'event-v1-acknowledge':
      case 'event-v1-player-id-verification':
      case 'event-v1-fulfill':
      case 'event-v1-clawback': {
        if (!hasEventId) {
          return cors(json({ ok: false, message: 'Missing eventId' }, 400, corId));
        }
        return cors(json({
          ok: true,
          message: 'Webhook verified successfully',
          namespace: body.namespace ?? null,
          productId: body.productId
        }, 200, corId));
      }
      default:
        return cors(json({ ok: false, message: 'Unsupported eventType' }, 400, corId));
    }
  },
};

/** ======= 工具函数 ======= */

function cors(res: Response): Response;
function cors(res: Response, status?: number): Response;
function cors(resOrBody: any, status?: number): Response {
  const res = resOrBody instanceof Response ? resOrBody : new Response(resOrBody, { status });
  const headers = new Headers(res.headers);
  headers.set('access-control-allow-origin', '*');
  headers.set('access-control-allow-methods', 'GET,POST,OPTIONS');
  headers.set('access-control-allow-headers', '*');
  headers.set('cache-control', 'no-store');
  // ⚠️ 不要把请求头（尤其 X-Signature）回显到响应
  return new Response(res.body, { status: res.status, headers });
}

function json(obj: unknown, status = 200, correlationId?: string): Response {
  const headers = new Headers();
  headers.set('content-type', 'application/json; charset=utf-8');
  if (correlationId) headers.set('x-epic-correlation-id', correlationId);
  return new Response(JSON.stringify(obj), { status, headers });
}

function isFreshTimestamp(tsIso: string, driftMs: number): boolean {
  const t = Date.parse(tsIso);
  if (Number.isNaN(t)) return false;
  const now = Date.now();
  return Math.abs(now - t) <= driftMs;
}

async function verifyEpicSignature(sigHeader: string, raw: Uint8Array, env: Env): Promise<boolean> {
  // 解析 "S4631=hex"
  const pairs = sigHeader.split(',').map(s => s.trim()).filter(Boolean);
  if (pairs.length === 0) return false;

  const map: Record<string, string> = {};
  for (const p of pairs) {
    const [k, v] = p.split('=');
    if (!k || !v) continue;
    map[k] = v;
  }

  // 仅支持你这把新 key（KID=S4631）
  const secretHex = env.WEBHOOK_SECRET_S4631;
  const sigHex = map['S4631'];

  if (!secretHex || !sigHex) return false;
  return await hmacEquals(raw, secretHex, sigHex);
}

async function hmacEquals(raw: Uint8Array, secretHex: string, sigHex: string): Promise<boolean> {
  const keyBytes = hexToBytes(secretHex);
  const key = await crypto.subtle.importKey('raw', keyBytes, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const mac = new Uint8Array(await crypto.subtle.sign('HMAC', key, raw));
  return bytesEq(mac, hexToBytes(sigHex));
}

function hexToBytes(hex: string): Uint8Array {
  const s = hex.trim().toLowerCase().replace(/^0x/, '');
  if (s.length % 2 !== 0) throw new Error('bad hex');
  const out = new Uint8Array(s.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(s.substr(i * 2, 2), 16);
  return out;
}

function bytesEq(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
  return diff === 0;
}
